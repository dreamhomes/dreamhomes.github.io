<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>那些年~一直刷的算法题 | 梦家博客</title><meta name="keywords" content="Leetcode"><meta name="author" content="梦家"><meta name="copyright" content="梦家"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="题源来自于：https:&#x2F;&#x2F;github.com&#x2F;Greatandy&#x2F;leetcode  刷题列表   两数之和：unordered_map遍历LC   两数相加：注意最后的进位不为0，LC   无重复字符最长子串：滑动窗口+unordered_map记录，LC   寻找两个正序数组的中位数：相当于找两个有序数组的第k大的数，二分，先判断k&#x2F;2和小数组长度大小。LC   最长回文子串: 二维动态"><meta property="og:type" content="article"><meta property="og:title" content="那些年~一直刷的算法题"><meta property="og:url" content="https://dreamhomes.top/posts/201910211448/"><meta property="og:site_name" content="梦家博客"><meta property="og:description" content="题源来自于：https:&#x2F;&#x2F;github.com&#x2F;Greatandy&#x2F;leetcode  刷题列表   两数之和：unordered_map遍历LC   两数相加：注意最后的进位不为0，LC   无重复字符最长子串：滑动窗口+unordered_map记录，LC   寻找两个正序数组的中位数：相当于找两个有序数组的第k大的数，二分，先判断k&#x2F;2和小数组长度大小。LC   最长回文子串: 二维动态"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img11.jpeg"><meta property="article:published_time" content="2019-10-21T14:48:44.000Z"><meta property="article:modified_time" content="2022-05-26T03:15:49.132Z"><meta property="article:author" content="梦家"><meta property="article:tag" content="Leetcode"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img11.jpeg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/favicon.png"><link rel="canonical" href="https://dreamhomes.top/posts/201910211448/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:20,languages:{author:"作者: 梦家",link:"链接: ",source:"来源: 梦家博客",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#6F42C1",bgDark:"#6F42C1",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-05-26 03:15:49"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const r=saveToLocal.get("global-font-size");void 0!==r&&document.documentElement.style.setProperty("--global-font-size",r+"px")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/css/custom/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="梦家博客" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/avatar.gif" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">183</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">63</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i> <span>书单</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i> <span>留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://sites.google.com/site/mengjiashen01/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img11.jpeg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">梦家博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i> <span>书单</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i> <span>留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://sites.google.com/site/mengjiashen01/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">那些年~一直刷的算法题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-21T14:48:44.000Z" title="发表于 2019-10-21 14:48:44">2019-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-26T03:15:49.132Z" title="更新于 2022-05-26 03:15:49">2022-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/">技术杂谈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/Leetcode/">Leetcode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/201910211448/#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>题源来自于：<a target="_blank" rel="noopener" href="https://github.com/Greatandy/leetcode">https://github.com/Greatandy/leetcode</a></p></blockquote><h2 id="刷题列表">刷题列表</h2><ol><li><p><strong>两数之和</strong>：unordered_map遍历<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">LC</a></p></li><li><p><strong>两数相加</strong>：注意最后的进位不为0，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">LC</a></p></li><li><p><strong>无重复字符最长子串</strong>：滑动窗口+unordered_map记录，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LC</a></p></li><li><p><strong>寻找两个正序数组的中位数</strong>：相当于找两个有序数组的第k大的数，二分，先判断k/2和小数组长度大小。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LC</a></p></li><li><p><strong>最长回文子串</strong>: 二维动态规划</p><p><code>dp[i] [j] = dp[i + 1] [j - 1]. if s[i + 1] [j - 1]</code></p><p>注意这个循环的遍历，外层是len from 0 to n，内层是i from 0 to n，j = i + len</p></li><li><p><strong>整数反转</strong>：注意是否越界，可以用INT_MAX / 10或者INT_MIN / 10判断一下. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer/submissions/">LC</a></p></li><li><p><strong>字符串转整数atoi</strong>：主要就是越界的处理，和6一样，注意一点的就是-12 % 10 = -2，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">LC</a></p></li><li><p><strong>正则表达式匹配</strong>：二维动态规划或者递归求解。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">LC</a></p><ul><li><p>dp[i] [j]：s的前i个和p的前j个是否匹配，dp[i] [0] = false, dp[0] [j] = dp[0] [j - 2] if p[j - 1] == ‘*’ dp[0] [0] = true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; slen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; plen + <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[j - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] != p[j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// abc与abc*</span></span><br><span class="line">        dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> first_match = (s.<span class="built_in">length</span>() &gt; <span class="number">0</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">  <span class="keyword">if</span> (p.<span class="built_in">length</span>() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isMatch</span>(s, p.<span class="built_in">substr</span>(<span class="number">2</span>, p.<span class="built_in">length</span>() - <span class="number">2</span>)) || (first_match &amp;&amp; <span class="built_in">isMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">length</span>() - <span class="number">1</span>), p));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first_match &amp;&amp; <span class="built_in">isMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">length</span>() - <span class="number">1</span>), p.<span class="built_in">substr</span>(<span class="number">1</span>, p.<span class="built_in">length</span>() - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>盛最多水的容器</strong>：双指针，每次选择小的方向往前/往后移动 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">LC</a></p></li><li><p><strong>罗马数字转整数</strong>： 一次遍历，遍历到第i时，看i + 1的数字，来判断+还是-。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/roman-to-integer/">LC</a></p></li><li><p><strong>数字转罗马数字</strong>：这个就把所有的罗马数字对应的数字列举出来，然后循环相减。 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-to-roman/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">string s[] = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> digits[] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(digits) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); i++) &#123;</span><br><span class="line">  <span class="keyword">while</span>(num &gt;= digits[i]) &#123;</span><br><span class="line">    res += s[i];</span><br><span class="line">    num -= digits[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最长公共前缀</strong>：横向比较，每次取两个算出最长公共前缀，得到的结果和后面一个继续算。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">LC</a></p></li><li><p><strong>三数之和</strong>：排序+双指针 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), third = <span class="number">0</span>, target = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; first++) &#123;</span><br><span class="line">  <span class="comment">/*先去重*/</span></span><br><span class="line">  <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  third = n - <span class="number">1</span>;</span><br><span class="line">  target = -nums[first];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; second++) &#123;</span><br><span class="line">    <span class="comment">/*先去重*/</span></span><br><span class="line">    <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (third &gt; second &amp;&amp; nums[third] + nums[second] &gt; target) &#123;  <span class="comment">//第二个指针从后往前遍历</span></span><br><span class="line">      third--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (third == second) <span class="comment">/*找不到，则后面second+1已经没有意义了，直接跳出循环，开始first+1的下一轮*/</span></span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">if</span> (nums[third] + nums[second] == target) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">// 注意四数求和亦是如此，多加一个for，另外target = -nums[first] - num[second]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>电话号码的字母组合</strong>：当循环数不定时，就去递归/回溯吧。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">LC</a></p></li><li><p><strong>删除链表倒数第N个节点</strong>：双指针，先走N个节点，再一起走。找到删除。 注意用一个dummy节点，放到头部。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LC</a></p></li><li><p><strong>有效的括号</strong>：栈解决，遇到左括号，就进栈，遇到右括号，就出栈，出的时候判断对错。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">LC</a></p></li><li><p><strong>合并两个有序链表</strong>：头部的判断，为了不用dummy，先判断两个链表是否都为空。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">LC</a></p></li><li><p><strong>括号生成</strong>：组合问题，就上回溯，回溯就是不断加左括号，回溯，弹出左括号，左括号数量大于右括号时，加右括号，回溯，弹出右括号。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">LC</a></p></li><li><p><strong>合并K个有序链表</strong>：归并排序的典型应用。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(vector&lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">    <span class="keyword">return</span> lists[left];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">  ListNode * L = <span class="built_in">Merge</span>(lists, left, mid);</span><br><span class="line">  ListNode * R = <span class="built_in">Merge</span>(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MergeTwoLists</span>(L, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除有序数组中的重复项</strong>：用一个临时变量一致保存前面的不一样的元素。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">LC</a></p></li><li><p><strong>实现strStr()</strong>：KMP算法，没法，只能硬背，不要尝试理解了，太费时间。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/">LC</a></p></li><li><p><strong>两数相除</strong>：倍增方法，注意把数都处理成负的，防止越界。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers/">LC</a></p></li><li><p><strong>旋转图像（90度</strong>）：两种方法：先主对角交换，再左右交换；或者 找到旋转后的递推关系：dp[i] [j]----&gt;dp[j] [n - i - 1] <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">LC</a></p></li><li><p><strong>搜索旋转排序数组</strong>：二分，注意先用nums[mid]和nums[left]相比较，确定[left, mid]和[mid+ 1, right]那个有序，再比较target和nums[left]/nums[right]进行比较 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">LC</a></p></li><li><p><strong>在排序数组中查找元素的第一个和最后一个位置</strong>: 二分，查找左边界，右边界。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LC</a></p></li><li><p><strong>有效的数独</strong>： 注意小数独的遍历[k / 3 * 3, k / 3 * 3 + 2]，[k % 3 * 3, k % 3 * 3 + 2] <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">LC</a></p></li><li><p><strong>外观数列</strong>：直接写。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">LC</a></p></li><li><p><strong>缺失的第一个正数</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-missing-positive/submissions/">LC</a> 原地置换，把[1, n]范围内的数对应的下标都取负。（这步之前先把&lt;=0的变成n+1)</p></li><li><p><strong>接雨水</strong>：考虑每个位置接多少雨水，也就是求左右两边在该位置最高高度的较小那个减去该位置高度。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">LC</a></p></li><li><p><strong>通配符匹配</strong>：二维动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j]: 表示s的前i个字符和p的前j个字符是否匹配</span></span><br><span class="line"><span class="keyword">if</span> (p[j] 是小写字母) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == p[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p[j] 是 ? ) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p[j] 是 <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>全排列</strong>：回溯法<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">LC</a></p></li><li><p><strong>字母异位词分组</strong>：使用hash，key是排序后的字符串，value是vector<string>，存的是原始的key。</string></p></li><li><p><strong>Pow(x, n)</strong>：主要考虑越界</p></li><li><p><strong>最大子序和</strong>：一维动态规划，dp[i] = dp[i - 1] + nums[i - 1] if dp[i - 1] &gt; 0 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">LC</a></p></li><li><p><strong>螺旋矩阵</strong>：确定好上下左右四个边界，遍历时一直更新，注意跳出条件<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">LC</a></p></li><li><p><strong>跳跃游戏</strong>：解法1: dp[i] = dp[i - k] &amp;&amp; nume[i - k] &gt;= k. 解法2: 贪心 记录当每一步能到的最大值.该值要大于等于i。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= rightmost) &#123;  <span class="comment">// 前面能达到的最大值(最大下标)</span></span><br><span class="line">    rightmost = <span class="built_in">max</span>(rightmost, i + nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>合并区间</strong>：先排序，然后插入。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/submissions/">LC</a></p></li><li><p><strong>不同路径</strong>：解法1: 动态规划。 解法2: 数学方法，组合问题。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">LC</a></p></li><li><p><strong>加1</strong>: 注意对9的处理。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/submissions/">LC</a></p></li><li><p><strong>x的平方根</strong>：典型的二分求左边界。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">LC</a></p></li><li><p><strong>爬楼梯</strong>：简单的dp。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">LC</a></p></li><li><p><strong>矩阵置零</strong>：用第一行第一列记录该行该列是否有0，然后再单独处理首列首行。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-matrix-zeroes/">LC</a></p></li><li><p><strong>颜色分类</strong>：双指针。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">LC</a></p></li><li><p><strong>最小覆盖子串</strong>：滑动窗口。比较难，用两个map存储，一个用于存储信息，一个用于记录窗口里的信息。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">LC</a></p></li><li><p><strong>子集</strong>：回溯法，选择本次元素，回溯，不选本次元素，回溯 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种回溯法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, vector&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="keyword">int</span> begin)</span> </span>&#123;  <span class="comment">// 需要传入本次元素的索引，传递引用是带着之前的记忆</span></span><br><span class="line">  <span class="keyword">if</span> (begin == nums.<span class="built_in">size</span>()) &#123;  <span class="comment">//求子集的结束条件，就是begin到最后</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 本次元素选择，回溯，撤销选择</span></span><br><span class="line">  temp.<span class="built_in">push_back</span>(nums[begin]);</span><br><span class="line">  <span class="built_in">backtrack</span>(nums, res, temp, begin + <span class="number">1</span>);</span><br><span class="line">  temp.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="built_in">backtrack</span>(nums, res, temp, begin + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, vector&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">  res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, res, temp, i + <span class="number">1</span>); </span><br><span class="line">    temp.<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>单词搜索</strong>：就是从每一个坐标，递归搜索. 回溯法。visted[i] [j] = true 回溯 false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index) <span class="comment">// i，j是坐标起始点；index是搜索到下标是index。用一个变量visited记录是否已经访问过</span></span><br><span class="line"><span class="comment">// 回溯时，先判断board[i][j] == word[index]，然后判断index == word.length() - 1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>柱状图中最大矩形</strong>：对于每个点，需要求出左边的第一个小于该点高度的坐标，右边第一个小于该点长度的坐标，这就需要递增栈，一个是i = 0…n-1，一个是i = n - 1…0。递增栈模板：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>() &gt;= heights[i]]) &#123;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  left[i] = st.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st.<span class="built_in">top</span>();</span><br><span class="line">  st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>合并两个有序数组</strong>：从后往前遍历 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">LC</a></p></li><li><p>解码方法：一维动态规划，dp[i]：表示s的前i个字符编码数。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - <span class="number">1</span>] <span class="keyword">if</span> s[i - <span class="number">1</span>]  <span class="comment">// 是合法字符</span></span><br><span class="line">dp[i] = dp[i] + dp[i - <span class="number">2</span>]  <span class="keyword">if</span> s[i - <span class="number">2</span>, i - <span class="number">1</span>]  <span class="comment">// 是合法字符</span></span><br></pre></td></tr></table></figure></li><li><p><strong>二叉树的中序遍历</strong>：递归和非递归两种写法。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">LC</a></p></li><li><p><strong>编辑距离</strong>：二维dp. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">LC</a></p></li><li><p><strong>验证二叉搜索树</strong>：递归，注意需要传递辅助信息：最小节点，最大节点。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/">LC</a></p></li><li><p><strong>对称二叉树</strong>：递归，需要辅助函数，输入是两个节点，判断这两个节点是否是对称的。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">LC</a></p></li><li><p><strong>二叉树的层序遍历</strong>：easy题，借助队列<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LC</a></p></li><li><p><strong>二叉树的锯齿形层序遍历</strong>：层序+双栈结合，再使用一个标识位来标识每次是左右孩子哪个先入栈。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/submissions/">LC</a></p></li><li><p><strong>二叉树的最大深度</strong>：max(l, r) + 1，递归。 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">LC</a></p></li><li><p><strong>从前序与中序遍历序列构造二叉树</strong>：找到根，递归构造左右子树。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LC</a></p></li><li><p><strong>将有序数组转换为二叉搜索树</strong>: 每次取中间节点，进行根节点的构建。 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">LC</a></p></li><li><p><strong>填充每个节点的下一个右侧节点指针</strong>：构建辅助函数，传入左右孩子节点。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">LC</a></p></li><li><p><strong>杨辉三角</strong>：easy，找到每一行元素与上一行元素的关系。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">LC</a></p></li><li><p><strong>买卖股票的最佳时机</strong>：easy，记录每个元素之前的最小元素值。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LC</a></p></li><li><p><strong>买卖股票的最佳时机II，不限次数</strong>：二维dp，其中第一维是第i天，第二维是持有/不持有。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LC</a></p></li><li><p><strong>二叉树的最大路径和</strong>：像这种不直接的题，肯定需要辅助函数，辅助函数记录每个节点加上其一个左右孩子节点中的一个可能构成的最大的边。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/submissions/">LC</a></p></li><li><p><strong>验证回文串</strong>：左右指针遍历即可。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">LC</a></p></li><li><p><strong>单词接龙</strong>：解法1: BFS求解，利用队列存每层结果，利用hashset存字典，再用一个hashset存已经访问过的节点（必须有，否则必出现死循环）。解法2: 双向BFS，一个hashset存字典，一个hashset存正向遍历，一个hashset存反向遍历，一个hashset存已经访问过的，每层遍历，交换前两个hashset。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">LC</a></p></li><li><p><strong>最长连续序列</strong>：一个hashset存储所有的，然后从begin开始，遍历begin，以及其所有上和下连续节点，遍历时不断删除，并同时更新最大连续值。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">LC</a></p></li><li><p><strong>被围绕的区域</strong>：先对边界的O进行DFS寻找其所有的O，都修改成#，然后把矩阵都变成X，再把所有的#都修改成O。核心是DFS那块，四个方向。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">LC</a></p></li><li><p><strong>分割回文串</strong>：这种分割问题，求组合的，等等，都是回溯法，这一题需要先用二维数组dp[i] [j]存储字符串中i到j是否是回文串。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">LC</a></p></li><li><p><strong>加油站</strong>：贪心，用两个变量分别记录gas-cost的累积和total和cur，如果cur小于0，则重新置cur=0，更新res为下一个i，继续记录。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/submissions/">LC</a></p></li><li><p><strong>只出现一次的数字</strong>：使用异或操作。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">LC</a></p></li><li><p><strong>复制带随机指针的链表</strong>：在每个节点后面多加一个节点，都加完以后再单独处理每个节点的random节点，然后再拆分。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">LC</a></p></li><li><p><strong>单词拆分</strong>：一维动态规划。 拿到题目如果没有思路，就想想能不能用动态规划来解决，不能再考虑回溯，BFS等方法。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// d[i] : 表示前i个字符是否可以被拆分都在单词表里</span></span><br><span class="line">dp[i] = dp[i - k] &amp;&amp; s[i-k+<span class="number">1.</span>..i] in wordDict</span><br></pre></td></tr></table></figure></li><li><p><strong>单词拆分II</strong>：就是求所有的可能，这种就是回溯法（DFS），确定回溯的输入参数，以及退出条件，回溯的可能步骤。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break-ii/submissions/">LC</a></p></li><li><p><strong>LRU缓存机制</strong>：使用双向链表存储key，value。使用unordered_map存储key和节点，方便寻找。注意get操作需要把访问的节点移动到链表头，put操作需要把访问的节点移动到头，超出capacity 的，要删除尾部的，所有过程都要更新map。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">LC</a></p></li><li><p><strong>排序链表</strong>：归并排序，每次找到链表的中点（注意奇数节点个数/偶数节点个数有点区别），把中点-&gt;next修改成nullptr。然后对这两段分别调用排序，排好序的，子集再调用合并两个链表的操作。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">LC</a></p></li><li><p><strong>直线上最多的点数</strong>：对于每一个点，统计该点与其他点的斜率，用unordered_map的key存储斜率，用value存储个数。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-points-on-a-line/">LC</a></p></li><li><p><strong>基本计算器II</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">LC</a></p></li><li><p><strong>寻找峰值</strong>：这个二分，有点意思。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">LC</a></p></li><li><p><strong>分数到小数</strong>：长除法，先判断分子分母是否为0，再判断正负，再判断是否能够整除，然后循环存储，并记录余数。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/submissions/">LC</a></p></li><li><p><strong>多数元素</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">LC</a></p></li><li><p><strong>逆波兰表达式求值</strong>：利用栈。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">LC</a></p></li><li><p><strong>乘积最大子数组</strong>：使用两个一维dp，注意压缩成临时状态时，变量不要叠加，要换成其他变量代替。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/submissions/">LC</a></p></li><li><p><strong>最小栈</strong>：使用两个栈。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">LC</a></p></li><li><p><strong>相交链表</strong>：先计算出两个链表长度差，然后让长的链表先走这个差，再一起走。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">LC</a></p></li><li><p><strong>N皇后</strong>：经典回溯。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">LC</a></p></li><li><p><strong>阶乘后的零</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">LC</a></p></li><li><p><strong>最大数</strong>：排序+重构比较函数。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-number/">LC</a></p></li><li><p><strong>旋转数组</strong>：三次翻转。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">LC</a></p></li><li><p><strong>颠倒二进制位</strong>：利用左移右移，n &amp; 1取最后一位。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/">LC</a></p></li><li><p><strong>位1的个数</strong>：每次利用n &amp; (n - 1)去掉右边的1 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/">LC</a></p></li><li><p><strong>打家劫舍</strong>：一维dp，easy。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">LC</a></p></li><li><p><strong>打家劫舍III</strong>：后续遍历。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">LC</a></p></li><li><p><strong>岛屿数量</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">LC</a></p></li><li><p><strong>快乐数</strong>：用一个set保存每次变换结果，如果某次结果在set里，说明重复出现过。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/happy-number/">LC</a></p></li><li><p><strong>计数质数</strong>：筛选法。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/">LC</a></p></li><li><p><strong>反转链表</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">LC</a></p></li><li><p><strong>课程表</strong>：要做某事，必须先做其他事，问是否有可能，说白了就是判断图中是否有环，拓扑排序。两种做法：一种是DFS：</p><p>一种是BFS：先构建邻接矩阵，并统计每个课程（节点）的入度。把入度为0的都加到队列中，然后遍历队列，弹出元素（入度为0的节点），以从邻接矩阵中找到以该节点为入度的其他节点，并分别将它们的入度都减去一。最后判断所有节点的入度是否为0。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">LC</a>，课程表II：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">LC</a></p></li><li><p>实现 Trie (前缀树)：创建时，先创建26个孩子节点，并都置为nullptr。insert时，对于某个字母，先判断以其为索引的孩子节点是否存在，不存在需要创建，遍历到最后，需要置结束标识位。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">LC</a></p></li><li><p>单词搜索II：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search-ii/">LC</a></p></li><li><p>存在重复元素：排序/哈希表<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">LC</a></p></li><li><p>天际线：使用一个vector排序，遍历，放到multiset里（右端点放进去，左端点出来），获取最大高度，更新结果。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-skyline-problem/">LC</a></p></li><li><p>二叉树中所有距离为K的结点：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">LC</a></p></li><li><p>二叉搜索树中第K小的元素：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">LC</a></p></li><li><p>回文链表：找到链表中点进行反转后半部分，再比较。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">LC</a></p></li><li><p>二叉树的最近公共祖先：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">LC</a></p></li><li><p>删除链表中的节点：赋值为链表下一个节点的值。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">LC</a></p></li><li><p>除自身以外数组的乘积：左右乘积列表。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">LC</a></p></li><li><p>滑动窗口最大值：维持一个非严格单调递减队列。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">LC</a></p></li><li><p>搜索二维矩阵：右上-&gt;左下搜索，可以用二分加快搜索<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">LC</a></p></li><li><p>有效的字母异位词：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">LC</a></p></li><li><p>缺失的数字：求和，再减。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">LC</a></p></li><li><p>完全平方数：返回和为n的完全平方数的最少数量，求最少这种问题，首先想到dp。</p><p>dp[n] = min(dp[n - i * i]). for i = 0…sqrt(n) init dp[n] = i. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">LC</a></p></li><li><p>移动零：把0移动数组的最左边/最右边，双指针，一个遍历，一个记录0的位置。<a href="">LC</a></p></li><li><p>寻找重复数：以对应数字-1的下标的数字改成负的。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">LC</a></p></li><li><p>生命游戏：每个位置都记录附近活细胞数目，对于该位置本来就是活细胞的，用正数表示；本来是死细胞的，用负数表示。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/game-of-life/">LC</a></p></li><li><p>数据流中的中位数：使用两个优先队列，一个是大顶堆（默认的）存放一半较小的数字，一个是小顶堆，存放一半较大的数字。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-median-from-data-stream/">LC</a> 插入是O(nlog(n))</p></li><li><p>二叉树的系列化和反序列化：序列化，就是前序遍历的递归。反序列化：dfs。这种写法不太好想，按照层序遍历写，会好点。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">LC</a></p></li><li><p>最长递增子序列：两种解法，一种一维dp[i]：表示以i为结尾的最长递增子序列。</p></li><li><p>计算右侧小于当前元素的个数：归并排序，相比逆序对，多了一个索引的存储。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">LC</a></p></li><li><p>数组中的逆序对：归并排序，归并的过程中，统计逆序对。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LC</a></p></li><li><p>零钱兑换：动态规划，完全背包问题。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">LC</a></p></li><li><p>摆动排序II：排序 + 前后一半反转 + 穿插合并。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-sort-ii/">LC</a></p></li><li><p>3的幂：就一直判断%3是否为0，然后除以3。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-three/">LC</a></p></li><li><p>奇偶链表：用两个指针，分别指向奇数偶数链表，交换节点。然后用一个指针记录偶数链表的头节点，最后连一下。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">LC</a></p></li><li><p>矩阵中的最长递增路径：对每个点dfs回溯+状态化记忆（如果用状态化记忆，必须用返回值比较好，否则只能传递引用）。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">LC</a></p></li><li><p>递增的三元子序列：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">LC</a></p></li><li><p>扁平化嵌套列表迭代器：dfs，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">LC</a></p></li><li><p>反转字符串：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string/">LC</a></p></li><li><p>前k个高频元素：先用hash map把元素和个数存起来，然后可以使用1）优先队列，2）vector+快排划分 两种方法求解。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">LC</a></p></li><li><p>两个数组的交集II：hash map <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">LC</a></p></li><li><p>两整数之和：不使用±，求两个数异或，然后求两个数与，并转化为unsigned int，然后右移，这两个相加。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-two-integers/">LC</a></p></li><li><p>有序矩阵中第 K 小的元素：两种解法：优先队列（基于堆的）和二分查找。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">LC</a></p></li><li><p>常数时间插入、删除和获取随机元素：使用一个vector用于存储数据，用一个hash map存储元素的值和索引。每次插入删除替换时都要考虑两个数据结构的更新。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">LC</a></p></li><li><p>打乱数组：使用一个vector保存原来的数组，然后对每个元素，都随机和后面的元素进行交换。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/">LC</a></p></li><li><p>字符串中的第一个唯一字符：两次遍历，用hash map存储数据。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">LC</a></p></li><li><p>至少有 K 个重复字符的最长子串：就dfs去寻找，对于每个字符串s，先统计其每个字母出现的次数，从头判断是否&gt;=k，找到第一个&lt;k的，递归其前半段和后半段。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">LC</a></p></li><li><p>Fizz Buzz：就简单的模拟就行。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fizz-buzz/">LC</a></p></li><li><p>四数相加II：双重for循环+hashmap 存储和和次数。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum-ii/">LC</a></p></li><li><p>会议室II：排序+优先队列。<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39722329/article/details/100641715">LC</a></p></li><li><p>火星字典：拓扑排序。<a target="_blank" rel="noopener" href="https://michael.blog.csdn.net/article/details/107346218">LC</a></p></li><li><p>寻找名人：贪心算法。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32424059/article/details/100550793">LC</a></p></li><li><p>二叉搜索树中的顺序后继：两种解法：非递归的中序遍历 和递归的利用BST的性质 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21201267/article/details/107131934">LC</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36094222/article/details/91309196">LC2</a></p></li><li><p>至多包含K个不同字符的最长子串：滑动窗口 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zjwreal/article/details/102070473">LC</a></p></li></ol><h2 id="剑指-offer">剑指 offer</h2><ol><li><p>0～n-1中缺失的数字：二分，注意二分初始化条件：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">LC</a></p></li><li><p>二叉搜索树的第k大节点：右-&gt;中-&gt;左遍历，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">LC</a></p></li><li><p>数组中出现的次数：异或运算。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">LC</a></p></li><li><p>数组中数字出现的次数II：bit位操作，就是统计某个bit位出现的次数，再对3取模。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">LC</a></p></li><li><p>旋转数组的最小数字：套用二分查找，旋转数组的话，比较num[mid]和num[right]，没有重复的好比较，有重复的，如果相等时，只能right–，这个细节注意。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">LC</a></p></li><li><p>二叉树之字打印：利用两个栈模拟，左右节点入栈和层的奇偶性。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">LC</a></p></li><li><p>二叉搜索树与双向链表：中序遍历，dfs，在遍历时引入两个辅助节点，head和pre（当前节点的前一个节点，由于无法获得后续节点，所以只能记录前一个节点。遍历到根节点，更新指针指向。）<a href="%5B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%5D(https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)">LC</a></p></li><li><p>字符串的排列：回溯法 + set去重。全是细节。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">LC</a></p></li><li><p>数字序列中某一位的数字: 统计每一数字的个数，以及位数，不断减去，获得可能在第哪个个数上的数字，然后获得第几个数字，进而获得该数字的第几位。 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">LC</a></p></li><li><p>1～n 整数中 1 出现的次数：获得每一位的数字cur，其高位的数high，低位的数low，以及该数字在第几位表示成10^i，即digit，然后根据cur的值来判断。本质上就是以cur=1，可能数。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">LC</a></p></li><li><p>把数字翻译成字符串：动态规划。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">LC</a></p></li><li><p>礼物的最大价值：简单的二维动态规划。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">LC</a></p></li><li><p>最长不含重复字符的子字符串：简单的滑动窗口题目。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">LC</a></p></li><li><p>丑数：记录上一个乘以2，3，5后大于当前数的数对应的索引，以及每一个丑数的值都要存下来。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/submissions/">LC</a></p></li><li><p>平衡二叉树：</p></li><li><p>和为s的连续正数序列：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">LC</a></p><p>思路就是用双指针，开始分别指向1和2，然后判断当前sum，如果&lt;target，right++，更新sum；如果&gt; target，left++，然后更新sum（sum-原来的left），如果=target，则把left～right的加到结果里。</p></li><li><p>滑动窗口的最大值：双端单调递减队列。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">LC</a></p></li><li><p>队列的最大值：此题解法和17里的题非常类似，不过这个是加了一个队列，用于弹出用。另外还需要一个单调递减双端队列。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">LC</a></p></li><li><p>n个骰子的点数：求每个点数出现的概率值，就是利用动态规划。概率题，动态规划的简单版本。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">LC</a></p></li><li><p>圆圈中最后剩下的数字：模拟思路就是从最后一轮的0开始地推这个数字是上一轮数字几，然后一直递推。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">LC</a></p></li><li><p>求1+2+…+n，两种解法，称之为天秀：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">LC</a></p></li><li><p>下一个排列：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">LC</a></p></li></ol><h2 id="牛客网">牛客网</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/activity/oj">link</a></p><ol><li><p>最长回文子串：如果用动态规划的话，外层for循环是遍历长度，内层for循环遍历i。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a> dp[i] [j]表示s[i] [j]是否是回文子串。</p></li><li><p>链表每k个数反转：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>三数之和：注意判断重复的细节，需要认真写好。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>LRU缓存：经典名题，值得多刷！<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a><br>本题思路就是双向链表（节点）+哈希表。同时每次更新时，既考虑链表的更新和删除，又要考虑哈希表的更新和删除。</p></li><li><p>LFU结构设计：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a> 每个频率对应一个双向链表节点，同时使用两个hash表分别用来对应key-节点位置，freq-双向链表节点（这个主要用来寻找最小频率对应的节点）。</p></li><li><p>两个字符串的最长公共子串：由于子串是必须连续的，所以二维dp[i] [j]：表示以字符串s1的第i个字符和字符串s2的第j个字符为结尾的最长公共子串。找到最长的，反向求结果。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>])  &#123; dp[i][j] =  dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>最长公共子序列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j]: 表示以str1的前i个字符和str2的前j个字符为结尾构成的最长公共子序列</span></span><br><span class="line">  <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>])</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">     dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])</span><br></pre></td></tr></table></figure></li><li><p>最长递增子序列：如果求长度，可以用动态规划以arr[i]为结尾的最长子序列长度，也可以用一个递增数组+二分。如果求序列本身，则还需要一个数组，保存以每个元素为结尾的最长递增子序列长度。有点巧妙，注意细节的优化。 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>合并区间： 注意区间包含的，eg：[1, 4] 和[2, 3]。 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>atoi：注意细节。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/44d8c152c38f43a1b10e168018dcc13f?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>判断是不是二叉搜索树：两种方法，递归和非递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归的函数接口设计</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBst</span><span class="params">(TreeNode* root, TreeNode* min_v, TreeNode* max_v)</span></span>;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">bool</span>&gt;&amp; vet, vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root || !vet[<span class="number">0</span>]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">inorder</span>(root-&gt;left, vet, v);</span><br><span class="line">  <span class="keyword">if</span>(!v.<span class="built_in">empty</span>() &amp;&amp; root-&gt;val &lt; v.<span class="built_in">back</span>()) vet[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">  v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">  <span class="built_in">inorder</span>(root-&gt;right, vet, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是不是完全二叉树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历的思想，说白了就是判断某个节点，如果左/右孩子节点缺失，则打上flag，后面的所有节点都不能有孩子节点。 核心代码</span></span><br><span class="line"><span class="keyword">if</span> (top-&gt;left) &#123;</span><br><span class="line">  <span class="keyword">if</span> (IsEnd) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(top-&gt;left);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  IsEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (top-&gt;right) &#123;</span><br><span class="line">  <span class="keyword">if</span> (IsEnd) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(top-&gt;right);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  IsEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>旋转数组寻找是否存在某个元素。 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7cd13986c79d4d3a8d928d490db5d707?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">牛客</a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">LC</a></p></li></ol><pre><code>注意，牛客上的答案更正确，考虑了数组不旋转的情况。
</code></pre><ol start="13"><li><p>滑动窗口最大值：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p>二叉树的遍历：三种方式，递归和非递归的。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>删除链表中的重复元素：不好写，有非递归和递归两种方式：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p><strong>树的直径</strong>：图的dfs。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a77b4f3d84bf4a7891519ffee9376df3?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">lc</a></p></li><li><p>约瑟夫环：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qie_wei/article/details/87915174">LC</a></p></li><li><p><strong>01背包问题和完全背包问题</strong>。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p>通配符匹配：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e96f1a44d4e44d9ab6289ee080099322?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p><strong>KMP算法</strong>的默写：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/bb1615c381cc4237919d1aa448083bcc?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>出现次数topK的问题通用解决方案：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fd711bdfa0e840b381d7e1b82183b3ee?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p>数组中只出现一次的数：按bit统计。 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p>二叉树中的最大路径和。 注意这一题要求路径的两个端点不一定是叶子节点。注意辅助函数的定义，以及辅助函数最后返回的值的计算。我在这里吃过亏。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>子数组最大乘积：注意最大的坑是，算出最新的max和min后，不能直接用，还是用之前的。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9c158345c867466293fc413cff570356?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">link</a></p></li><li><p>括号生成：回溯法，引入辅助函数，引入辅助变量：左括号的数量，注意传递字符串引用时，不要带引用，这个是坑。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c9addb265cdf4cdd92c092c655d164ca?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a> 如果非要带引用，注意写法要修改：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">LC</a></p></li><li><p>最大公约数，两行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数字字符串转化为IP地址</strong>：就是回溯法，注意判断0数字（回溯首位遇到0，必须加分割符）。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ce73540d47374dbe85b3125f57727e1e?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p><strong>加起来和为目标值的组合</strong>：sort + 回溯 + 去重（for循环里去重），很难想，值得多刷。。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/75e6cd5b85ab41c6a7c43359a74e869a?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p><strong>表达式求值</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">LC</a></p></li><li><p>N的阶乘里0的个数：<a href="">LC</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n / <span class="number">5</span> + <span class="built_in">thenumberof0</span>(n / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><hr><img src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/20210719160513.png" alt="联系作者" style="zoom:38%"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">梦家</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://dreamhomes.top/posts/201910211448/">https://dreamhomes.top/posts/201910211448/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dreamhomes.top" target="_blank">梦家博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img11.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/201910222055/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img3.jpeg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Alias 随机采样及其 Python 实现</div></div></a></div><div class="next-post pull-right"><a href="/posts/201910211012/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img9.jpeg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DevNet：基于偏差网络的深度异常检测模型</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/avatar.gif" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/friend_404.gif"' alt="avatar"><div class="author-info__name">梦家</div><div class="author-info__description">算法工程师｜机器学习<br><br>前 途 似 海 渺 渺<br>来 日 方 长 漫 漫<br>与 其 互 为 人 间<br>不 如 自 成 宇 宙</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">183</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">63</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dreamhomes"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dreamhomes" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:shenmj13@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/DreamHome_S" target="_blank" title="CSDN"><i class="fab fa-cuttlefish"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>重要通知</span></div><div class="announcement_content">如对本站内容存在任何疑问 🧐 欢迎 <a href="https://dreamhomes.top/comments/">留言</a> 反馈或者联系作者<br><br><center><img src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/20210910100633.png" alt="联系博主" style="zoom:72%"></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E5%88%97%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">刷题列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-offer"><span class="toc-number">2.</span> <span class="toc-text">剑指 offer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E7%BD%91"><span class="toc-number">3.</span> <span class="toc-text">牛客网</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/202204281516/" title="智能运维 AIOps 系列丨调用链根因定位算法综述"><img data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img12.jpeg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/404.jpg"' alt="智能运维 AIOps 系列丨调用链根因定位算法综述"></a><div class="content"><a class="title" href="/posts/202204281516/" title="智能运维 AIOps 系列丨调用链根因定位算法综述">智能运维 AIOps 系列丨调用链根因定位算法综述</a><time datetime="2022-04-28T15:16:58.000Z" title="发表于 2022-04-28 15:16:58">2022-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/202204241101/" title="Chart Studio &amp; Datapane：优雅地将 Plotly 图嵌入到 Markdown 文件中进行可视化分析"><img data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img6.jpeg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/404.jpg"' alt="Chart Studio &amp; Datapane：优雅地将 Plotly 图嵌入到 Markdown 文件中进行可视化分析"></a><div class="content"><a class="title" href="/posts/202204241101/" title="Chart Studio &amp; Datapane：优雅地将 Plotly 图嵌入到 Markdown 文件中进行可视化分析">Chart Studio &amp; Datapane：优雅地将 Plotly 图嵌入到 Markdown 文件中进行可视化分析</a><time datetime="2022-04-24T11:01:59.000Z" title="发表于 2022-04-24 11:01:59">2022-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/202204221627/" title="ICSE 2022丨DeepTraLog：GNN 和 Trace-Log 数据相结合的微服务异常检测方法"><img data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img9.jpeg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/404.jpg"' alt="ICSE 2022丨DeepTraLog：GNN 和 Trace-Log 数据相结合的微服务异常检测方法"></a><div class="content"><a class="title" href="/posts/202204221627/" title="ICSE 2022丨DeepTraLog：GNN 和 Trace-Log 数据相结合的微服务异常检测方法">ICSE 2022丨DeepTraLog：GNN 和 Trace-Log 数据相结合的微服务异常检测方法</a><time datetime="2022-04-22T16:27:43.000Z" title="发表于 2022-04-22 16:27:43">2022-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/202204221003/" title="齐夫定律 (Zipf' law) 理论及其应用场景"><img data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img6.jpeg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/404.jpg"' alt="齐夫定律 (Zipf' law) 理论及其应用场景"></a><div class="content"><a class="title" href="/posts/202204221003/" title="齐夫定律 (Zipf' law) 理论及其应用场景">齐夫定律 (Zipf' law) 理论及其应用场景</a><time datetime="2022-04-22T10:03:07.000Z" title="发表于 2022-04-22 10:03:07">2022-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/202204201700/" title="大规模图可视化分析框架 Graphistry"><img data-lazy-src="https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img2.jpeg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/404.jpg"' alt="大规模图可视化分析框架 Graphistry"></a><div class="content"><a class="title" href="/posts/202204201700/" title="大规模图可视化分析框架 Graphistry">大规模图可视化分析框架 Graphistry</a><time datetime="2022-04-20T17:00:42.000Z" title="发表于 2022-04-20 17:00:42">2022-04-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://cdn.jsdelivr.net/gh/dreamhomes/blog-image-bed@master/top/dreamhomes/butterflyblog/imgs/img11.jpeg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 梦家</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img src="https://cdn.jsdelivr.net/gh/dreamhomes/dreamhomes.github.io@master/img/icp.png"> <span>赣ICP备 20003744 号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>document.getElementsByClassName("mermaid").length&&(window.mermaidJsLoad?mermaid.init():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(()=>{window.mermaidJsLoad=!0,mermaid.initialize({theme:"default"})}))</script><script>(()=>{const o=document.getElementById("twikoo-count"),t=()=>{let o={el:"#twikoo-wrap",envId:"hello-cloudbase-7gmvk17h649821e3",region:""};twikoo.init(o)},e=()=>{twikoo.getCommentsCount({envId:"hello-cloudbase-7gmvk17h649821e3",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))},n=(n=!1)=>{"object"==typeof twikoo?(t(),n&&o&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{t(),n&&o&&setTimeout(e,0)})};n(!0)})()</script><script>function loadValine(){function e(){let e={el:"#vcomment",appId:"1JeI4r7MuSNuHIKgevu6uP8q-gzGzoHsz",appKey:"Ykl58TSExNWvTIyBTbnmp26h",placeholder:"💗 Hi, see you tomorrow. 💗",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"https://1jei4r7m.lc-cn-n1-shared.com",emojiCDN:"",emojiMaps:"",enableQQ:!1,path:window.location.pathname,master:"7a7f78ed775ede7059cf68eb46898cc5".split(","),friends:"5d7570d1f1fefc9918c797ee65af3899,ec18c657f7ea8128e4bb73e96e45d236,d304727a8d439e45b08f8579666ee818".split(","),tagMeta:"博主,伙伴,访客".split(",")};e.requiredFields="nick,mail".split(",");new Valine(e)}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js").then(e)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script></div><script defer id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("recent-posts").insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>'),console.log("已挂载gitcalendar")}document.getElementById("recent-posts")&&"/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("https://gitcalendar.akilar.top/api?dreamhomes",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"dreamhomes"))</script></body></html>